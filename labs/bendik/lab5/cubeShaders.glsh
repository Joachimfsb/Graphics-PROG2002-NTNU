#include <string>

const std::string CUBE_FRAGMENT_SHADER = R"(
    #version 430 core

    in vec4 v_Position;
    in vec3 v_fragPosition;
    in vec3 v_NormalVector;

    layout(binding = 1) uniform samplerCube uTexture;
    uniform vec4 u_Color;
    uniform vec3 u_lightSourcePosition;
    uniform vec3 u_lightColor;
    uniform vec3 u_cameraPosition;
    uniform float u_specularStrength = 0.5;
    uniform float u_diffuseStrength = 0.5;
    uniform float u_ambientStrength = 0.5;
    uniform float u_shinynessFactor = 32;

    out vec4 color;

    void main()
    {
        // Primary color
        vec3 primary = mix(u_Color, texture(uTexture, v_Position.xyz), 0.8f).xyz;

        // Ambient color
        float ambient = u_ambientStrength;

        // Diffuse color
        vec3 norm = normalize(v_NormalVector);
        vec3 lightDirection = normalize(u_lightSourcePosition - v_fragPosition); // Get direction of light
        float diff = max(dot(norm, lightDirection), 0.0f);
        vec3 diffuse = u_diffuseStrength * diff * u_lightColor;

        // Specular color
        vec3 observerDirection = normalize(u_cameraPosition - v_fragPosition);
        vec3 reflectedLight = reflect(-lightDirection, norm);
        float specFactor = pow(max(dot(observerDirection, reflectedLight), 0.0), u_shinynessFactor);
        vec3 specular = u_specularStrength * specFactor * u_lightColor;

        // Final color
        color = vec4(primary * (ambient + diffuse + specular), 1.0);
    }
    )";



const std::string CUBE_VERTEX_SHADER = R"(
    #version 430 core

    layout(location = 0) in vec3 a_Position;
    layout(location = 1) in vec3 a_NormalVector;

    uniform mat4 u_Model;
    uniform mat4 u_View;
    uniform mat4 u_Projection;

    out vec4 v_Position;
    out vec3 v_fragPosition;
    out vec3 v_NormalVector;

    void main()
    {
        gl_Position = u_Projection * u_View * u_Model * vec4(a_Position, 1.0f);

        v_Position = vec4(a_Position, 1.0);
        v_fragPosition = (u_Model * vec4(a_Position, 1.0)).xyz;
        v_NormalVector = mat3(transpose(inverse(u_Model))) * a_NormalVector;
    }
    )";